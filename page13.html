<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Moshi Moshi</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300&display=swap" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="./assets/main.css">
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.0/gsap.min.js"></script>
		<script src="./jsm/lottie_canvas.js"></script>

		<style>
			body {
				color: #000;
				overflow-x:hidden;
				overflow-y:hidden;
				font-family: 'Nunito', sans-serif;
				background-color: #fafeff;
				background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100%25' height='100%25' viewBox='0 0 1600 800'%3E%3Cg fill-opacity='0.54'%3E%3Cpath fill='%23d7f0fe' d='M486 705.8c-109.3-21.8-223.4-32.2-335.3-19.4C99.5 692.1 49 703 0 719.8V800h843.8c-115.9-33.2-230.8-68.1-347.6-92.2C492.8 707.1 489.4 706.5 486 705.8z'/%3E%3Cpath fill='%23b6d8fb' d='M1600 0H0v719.8c49-16.8 99.5-27.8 150.7-33.5c111.9-12.7 226-2.4 335.3 19.4c3.4 0.7 6.8 1.4 10.2 2c116.8 24 231.7 59 347.6 92.2H1600V0z'/%3E%3Cpath fill='%2396b7f5' d='M478.4 581c3.2 0.8 6.4 1.7 9.5 2.5c196.2 52.5 388.7 133.5 593.5 176.6c174.2 36.6 349.5 29.2 518.6-10.2V0H0v574.9c52.3-17.6 106.5-27.7 161.1-30.9C268.4 537.4 375.7 554.2 478.4 581z'/%3E%3Cpath fill='%23798fee' d='M0 0v429.4c55.6-18.4 113.5-27.3 171.4-27.7c102.8-0.8 203.2 22.7 299.3 54.5c3 1 5.9 2 8.9 3c183.6 62 365.7 146.1 562.4 192.1c186.7 43.7 376.3 34.4 557.9-12.6V0H0z'/%3E%3Cpath fill='%235e63e5' d='M181.8 259.4c98.2 6 191.9 35.2 281.3 72.1c2.8 1.1 5.5 2.3 8.3 3.4c171 71.6 342.7 158.5 531.3 207.7c198.8 51.8 403.4 40.8 597.3-14.8V0H0v283.2C59 263.6 120.6 255.7 181.8 259.4z'/%3E%3Cpath fill='%237e82ea' d='M1600 0H0v136.3c62.3-20.9 127.7-27.5 192.2-19.2c93.6 12.1 180.5 47.7 263.3 89.6c2.6 1.3 5.1 2.6 7.7 3.9c158.4 81.1 319.7 170.9 500.3 223.2c210.5 61 430.8 49 636.6-16.6V0z'/%3E%3Cpath fill='%239ea1ef' d='M454.9 86.3C600.7 177 751.6 269.3 924.1 325c208.6 67.4 431.3 60.8 637.9-5.3c12.8-4.1 25.4-8.4 38.1-12.9V0H288.1c56 21.3 108.7 50.6 159.7 82C450.2 83.4 452.5 84.9 454.9 86.3z'/%3E%3Cpath fill='%23bfc1f5' d='M1600 0H498c118.1 85.8 243.5 164.5 386.8 216.2c191.8 69.2 400 74.7 595 21.1c40.8-11.2 81.1-25.2 120.3-41.7V0z'/%3E%3Cpath fill='%23dfe0fa' d='M1397.5 154.8c47.2-10.6 93.6-25.3 138.6-43.8c21.7-8.9 43-18.8 63.9-29.5V0H643.4c62.9 41.7 129.7 78.2 202.1 107.4C1020.4 178.1 1214.2 196.1 1397.5 154.8z'/%3E%3Cpath fill='%23ffffff' d='M1315.3 72.4c75.3-12.6 148.9-37.1 216.8-72.4h-723C966.8 71 1144.7 101 1315.3 72.4z'/%3E%3C/g%3E%3C/svg%3E");
				background-attachment: fixed;
				background-repeat:repeat;
				background-size: cover;
				background-position: center center;
			}

			.frame {
			  position: absolute;
			  top: 35%;
			  left: 50%;
			  width: 400px;
			  height: 400px;
			  margin-top: -200px;
			  margin-left: -200px;
			  border-radius: 2px;
			  z-index:600;
			  color: #fff;
			  opacity:0;
			  transition: opacity 0.9s ease-in-out;
			}

            canvas {
    display: block;
}

#canvas_container {
    width: 100%;
    height: 100vh;
}

    #start-button{
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%);
        display: none;
    }

    #desc-hldr{
        position: absolute;
        bottom: 0;
        left: 0;
        width: 14rem;
        opacity: 0;
        transition: opacity 0.4s ease-in-out;
        /* font-weight: bold; */
        color: white;
    }

    #desc-hldr .title{
        margin: 0.4rem 0;
        font-size: 1.5rem;
        line-height: 1.75rem;
        font-weight: 600;
    }

    .divider{
        width: 100%;
        height: 1px;
        background: #ffffff;
        border-radius: 6px;
    }

    #desc-hldr .desc{
        padding: 0.4rem 0.4rem 0 0;
        font-size: 0.9rem;
        line-height: 1.2rem;
    }

    .desc-wrapper{
        display: flex;
    }

    .circles-hldr{
        display: flex;
        padding-top: 0.4rem;
    }

    .circles-hldr .circle{
        background: white;
        width: 8px;
        height: 8px;
        border-radius: 19px;
        display: flex;
        margin: 5px 2px 5px 3px;
    }

			
		</style>
		<script>
		 var camerag, sceneg, meshg, rendererg;

		</script>
	</head>

	<body>
		<div id="desc-hldr">
            <h2 class="title">BUSINESS PROCESSES SUITE</h2>
            <div class="divider"></div>
            <div class="desc-wrapper">
                <div class="desc">This is some randome description</div>
                <div class="circles-hldr">
                    <div class="row">
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                    </div>
                    <div class="row">
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                    </div>
                    <div class="row">
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                    </div>
                    <div class="row">
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                        <span class="circle"></span>
                    </div>
                    
                </div>
            </div>
            
        </div>

        <button id="start-button" onclick="handleEnterClick()">Enter</button>

        <div id="canvas_container"></div>


		<script type="module">

			import * as THREE from './build/three.module.js';

			import { OrbitControls } from './jsm/OrbitControls.js';
            import { PointerLockControls } from './jsm/PointerLockControls.js';
            import { SVGLoader } from './jsm/SVGLoader.js';
			import { LottieLoader } from './jsm/LottieLoader.js';
			import { TransformControls } from './jsm/TransformControls.js';
            import { GLTFLoader } from './jsm/GLTFLoader.js';

			import { EffectComposer } from './jsm/EffectComposer.js';
			import { RenderPass } from './jsm/RenderPass.js';
			import { UnrealBloomPass } from './jsm/UnrealBloomPass.js';

            import { GUI } from './jsm/lil-gui.module.min.js';

			let renderer,
            scene,
            camera,
            sphereBg,
            nucleus,
            stars,
            bloomPass,
            composer,
            controls,
            plControls,
            container = document.getElementById("canvas_container"),
            timeout_Debounce,
            //noise = new SimplexNoise(),
            cameraSpeed = 0,
            bloomAnimationCounter = 0,
            materialSphereBg,
            originPos,
            planeMesh,
            descWrapper,
            descTitle,
            descDesc,
            blobScale = 3;

            let raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3());
			const pointer = new THREE.Vector2();
            const mouse3D = new THREE.Vector3();
            let model2, selectedObjectIndex = -1;

            let bgTextures = [];

            let starMat = new THREE.MeshBasicMaterial({transparent: true });
            let periodicAnimationCounter = 0;

            const params = {
				exposure: 0.1,
				bloomThreshold: 0.963,
                bloomStrength: 0.381,
				bloomRadius: 0.26,
                distance: 100,
			}; 

            const starsPos = [{
                x: 498, 
                y: 468,
                z: 698,
            },{
                x: 845, 
                y: 91,
                z: -285,
            },{
                x: -536, 
                y: -146,
                z: -632,
            },
            {
                x: 217, 
                y: 585,
                z: -782,
            } 
            ];

            const constellations = [{
                scale: {x: 15, y:15, z:15},
                position: {x:-449, y:-110, z:-454},
                name: 'constel1',
                camPos: {x: 311, y:2, z: 264 },
                camLook: {x: -0.76, y: -6.12, z: - 0.64},
                title: 'BUSINESS COMMUNICATIONS SUITE',
                desc: 'This is some description about business communication'
            },{
                scale: {x: 13, y:13, z:13},
                position: {x:156, y:469, z:-539},
                name: 'constel2',
                camPos: {x: -127 , y:-187, z: 339 },
                camLook: {x: 0.31, y: 0.45, z: -0.83},
                title: 'BUSINESS PROCESSES SUITE',
                desc: 'This is some description about business communication'
            },
            {
                scale: {x: 14, y:14, z:14},
                position: {x:718, y:85, z:-197},
                name: 'constel3',
                camPos: {x: -403, y:-20, z: 59 },
                camLook: {x: 0.98, y: 0.05, z: -0.14},
                title: 'PRODUCTIVITY SUITE',
                desc: 'This is some description about business communication'
            },
            {
                scale: {x: 15, y:15, z:15},
                position: {x:295, y:316, z:568},
                name: 'constel4',
                camPos: {x: -144, y:-102, z: -368 },
                camLook: {x: 0.35, y: 0.25, z: 0.90},
                title: 'GUIDANCE SUITE',
                desc: 'This is some description about business communication'
            }];

            const planes = [];

            init();
            animate();

            

            function init() {
                scene = new THREE.Scene();
                sceneg = scene;

                originPos = {x: 182, y: 2, z: 366};

                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
                //camera.position.set(originPos.x, originPos.y, originPos.z);
                //camera.lookAt(-0.44, -6.12, -0.89);
                camera.position.set(-531, -45, 481);
                camera.lookAt(0.74, 0.06, -0.66);
                camerag = camera;

                const directionalLight = new THREE.DirectionalLight("#fff", 2);
                directionalLight.position.set(0, 50, -20);
                //scene.add(directionalLight);

                let ambientLight = new THREE.AmbientLight("#ffffff", 1);
                ambientLight.position.set(0, 20, 20);
                //scene.add(ambientLight);

                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    /*alpha: true*/
                });
                renderer.setSize(container.clientWidth, container.clientHeight);
                //renderer.toneMapping = THREE.ACESFilmicToneMapping;
                //renderer.toneMapping = THREE.ReinhardToneMapping;
                //renderer.outputEncoding = THREE.sRGBEncoding;
                //renderer.toneMappingExposure = 0.6;
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                //OrbitControl
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                //controls.maxDistance = 450;
                //controls.minDistance = 150;
                //controls.enablePan = false;
                //controls.enableZoom = false;
                //controls.enabled = false;
                controls.maxPolarAngle = Math.PI / 1.5;
                controls.minPolarAngle = Math.PI / 2.0;

                plControls = new PointerLockControls( camera, renderer.domElement);

                //scene.add( plControls.getObject() );

                

                function handleEnterClick(){
                    plControls.lock();

                    document.getElementById('start-button').style.display = 'none';
                }

                window.handleEnterClick = handleEnterClick;

                

                const renderScene = new RenderPass( scene, camera );

				bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );


                const loader = new THREE.TextureLoader();
                const textureSphereBg = loader.load('./assets/moshieq1.jpg');

                const constellation1Tex = loader.load('./assets/constellations/1.png');
                constellations[0].map = constellation1Tex;
                const constellation2Tex = loader.load('./assets/constellations/2.png');
                constellations[1].map = constellation2Tex;
                const constellation3Tex = loader.load('./assets/constellations/3.png');
                constellations[2].map = constellation3Tex;
                const constellation4Tex = loader.load('./assets/constellations/4.png');
                constellations[3].map = constellation4Tex;

                const bg1Tex = loader.load('./assets/constellations/bg1.png');
                bgTextures.push(bg1Tex);
                const bg2Tex = loader.load('./assets/constellations/bg2.png');
                bgTextures.push(bg2Tex);
                const bg3Tex = loader.load('./assets/constellations/bg3.png');
                bgTextures.push(bg3Tex);
                const bg4Tex = loader.load('./assets/constellations/bg4.png');
                bgTextures.push(bg4Tex);

                const transparentTex = loader.load('./assets/constellations/transparent.png');




                /*    Sphere  Background   */
                textureSphereBg.anisotropy = 32;
                let geometrySphereBg = new THREE.SphereBufferGeometry(900, 60, 60);
                materialSphereBg = new THREE.MeshBasicMaterial({
                    side: THREE.BackSide,
                    map: textureSphereBg,
                });
                sphereBg = new THREE.Mesh(geometrySphereBg, materialSphereBg);
                sphereBg.position.y += 200;
                scene.add(sphereBg);


                const planeGeometry = new THREE.PlaneGeometry( 30, 30 );
                const planeMaterial = new THREE.MeshBasicMaterial( { map: constellation1Tex, transparent: true} );
                planeMesh = new THREE.Mesh( planeGeometry, planeMaterial );
                //scene.add( planeMesh );

                createConstellations();

                //calculateStarsPosition();

                /*    Moving Stars   */
                /*let starsGeometry = new THREE.Geometry();

                for (let i = 0; i < 50; i++) {
                    let particleStar = randomPointSphere(150); 

                    particleStar.velocity = THREE.MathUtils.randInt(50, 200);

                    particleStar.startX = particleStar.x;
                    particleStar.startY = particleStar.y;
                    particleStar.startZ = particleStar.z;

                    starsGeometry.vertices.push(particleStar);
                }
                let starsMaterial = new THREE.PointsMaterial({
                    size: 5,
                    color: "#ffffff",
                    transparent: true,
                    opacity: 0.8,
                    map: textureStar,
                    blending: THREE.AdditiveBlending,
                });
                starsMaterial.depthWrite = false;  
                stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(stars); */

                


                function createConstellations(){

                    let index = 0;

                    constellations.forEach((constellation) => {
                        const planeGeo = new THREE.PlaneGeometry(30,30);
                        const mat = new THREE.MeshBasicMaterial({ transparent: true, map: constellation.map});

                        const planeMesh = new THREE.Mesh(planeGeo, mat);
                        planeMesh.name = constellation.name;
                        planeMesh.userData.index = index;
                        planeMesh.scale.set(constellation.scale.x, constellation.scale.y, constellation.scale.z);
                        planeMesh.position.set(constellation.position.x, constellation.position.y, constellation.position.z);
                        
                        planeMesh.userData.vertices = createVerticesArray(planeGeo.attributes.position.array);

                        planes.push(planeMesh);
                        scene.add(planeMesh);
                        index++;
                    });

                }    


                /*    Fixed Stars   */
                function createStars(texture, size, total) {
                    let pointGeometry = new THREE.Geometry();
                    let pointMaterial = new THREE.PointsMaterial({
                        size: size,
                        map: texture,
                        blending: THREE.AdditiveBlending,                      
                    });

                    for (let i = 0; i < total; i++) {
                        let radius = THREE.MathUtils.randInt(149, 70); 
                        let particles = randomPointSphere(radius);
                        pointGeometry.vertices.push(particles);
                    }
                    return new THREE.Points(pointGeometry, pointMaterial);
                }
               /* scene.add(createStars(texture1, 15, 20));   
                scene.add(createStars(texture2, 5, 5));
                scene.add(createStars(texture4, 7, 5));*/


                function randomPointSphere (radius) {
                    let theta = 2 * Math.PI * Math.random();
                    let phi = Math.acos(2 * Math.random() - 1);
                    let dx = 0 + (radius * Math.sin(phi) * Math.cos(theta));
                    let dy = 0 + (radius * Math.sin(phi) * Math.sin(theta));
                    let dz = 0 + (radius * Math.cos(phi));
                    return new THREE.Vector3(dx, dy, dz);
                }


                descWrapper = document.getElementById('desc-hldr');
                descTitle = document.querySelector('#desc-hldr .title');
                descDesc = document.querySelector('#desc-hldr .desc');

                controls.addEventListener( 'start', ()=> {
                    selectedObjectIndex = -1;
                    descWrapper.style.opacity = 0;
                } );
            }


            function animate() {

    

                //Sphere Beckground Animation
                //sphereBg.rotation.x += 0.002;
                //sphereBg.rotation.y += 0.003;
                //sphereBg.rotation.x += 0.0001;
                /*if(meshg){
                    meshg.rotation.y += 0.0025;
                    model2.rotation.y += 0.0025;
                }*/
                //sphereBg.rotation.z += 0.002;

                if(bloomAnimationCounter % 2 == 0){
                   /* if(starMat.opacity >= 0.2 && starMat.opacity <= 1.0)
                    starMat.opacity -= 0.05;
                    else{
                        starMat.opacity += 0.2;
                    }*/

                    //starMat.opacity = THREE.MathUtils.clamp(Math.abs(Math.cos(Math.PI * periodicAnimationCounter)), 0.3, 1.0);
                    //console.log(periodicAnimationCounter);
                    //console.log(Math.abs(Math.cos(Math.PI * periodicAnimationCounter)));
                    //Math.cos(periodicAnimationCounter);
                    //starMat.needsUpdate = true;
                    
                    planes.forEach((plane) => {
                        plane.quaternion.copy(camera.quaternion);
                        plane.material.opacity = THREE.MathUtils.clamp(Math.abs(Math.cos(Math.PI * periodicAnimationCounter)), 0.3, 1.0); 
                        plane.material.needsUpdate = true;
                    });

                    periodicAnimationCounter += 0.01;
                    
                    
                    //planeMesh.quaternion.copy(camera.quaternion);


                }

                if(selectedObjectIndex !== -1){
                        const ssbb = computeScreenSpaceBoundingBox2(planes[selectedObjectIndex]);
                        descWrapper.style.left = Math.floor(ssbb.max.x) + 'px';
                        descWrapper.style.bottom = Math.floor(ssbb.min.y) + 'px';   
                }

                bloomAnimationCounter++;

                controls.update();
                //stars.geometry.verticesNeedUpdate = true;
                renderer.render(scene, camera);
                //composer.render();


                requestAnimationFrame(animate);
            }



            /*     Resize     */
            window.addEventListener("resize", () => {
                clearTimeout(timeout_Debounce);
                timeout_Debounce = setTimeout(onWindowResize, 80);
            });

            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }

            function createVerticesArray(posArray){
                const vertArray = [];
                let i= 0;
                while(i< posArray.length){
                    const vert = new THREE.Vector3(posArray[i++], posArray[i++], posArray[i++]);
                    vertArray.push(vert);
                }

                return vertArray;

        
            }

            

            function handleRaycast(event){
                
                if(bloomAnimationCounter % 10 == 0){
                    pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
                    pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

                    raycaster.setFromCamera( pointer, camera );

                    const intersects = raycaster.intersectObjects( scene.children, true );

                    if(intersects.length > 0){

                        
                        
                        const clickedMesh = intersects[0].object;

                       
                        
                        if(clickedMesh.name.startsWith('constel') && clickedMesh.userData.index !== selectedObjectIndex){
                           
                            
                            descWrapper.style.opacity = 0;
                           
                            setTimeout(() => {
                                descWrapper.style.opacity = 1.0;
                            }, 3000);
                            
                            
                            selectedObjectIndex = clickedMesh.userData.index;

                            descTitle.innerText = constellations[selectedObjectIndex].title;
                            descDesc.innerText = constellations[selectedObjectIndex].desc;

                            controls.enabled = false;
                            gsap.to(camera.position, { ...constellations[selectedObjectIndex].camPos, duration:8, ease:"",onComplete: () => {
                                setTimeout(() => {
                                    controls.enabled = true;
                                }, 1000);
                                
                            }});

                            //camera.position.copy(constellations[selectedObjectIndex].camPos);

                        }
                        
                    }
                }

                
                


            }

            //window.addEventListener("pointerdown", handleRaycast);
            window.addEventListener("pointermove", handleRaycast);


            function handleRaycast2(objData){
                
                selectedObjectIndex = objData.index;
                const selectedObjMat = meshg.children[selectedObjectIndex].material;

                //selectedObjMat.color.set(0x000000);
                //selectedObjMat.needsUpdate = true;

                const selectedBGMat = model2.children[selectedObjectIndex].material;
                selectedBGMat.map = bgTextures[selectedObjectIndex];
                selectedBGMat.needsUpdate = true;

                gsap.to(selectedBGMat, { opacity: 0.85, duration:1, ease:"expo.out", onUpdate: () => {
                    selectedBGMat.needsUpdate = true;
                },onComplete: () => {
						
						
						//createInnerPage1();

						//showAnnotations = true;	
						//controls.target.set(annotations[id].position.x, annotations[id].position.y, annotations[id].position.z );
						//gsap.fromTo(annotDescHolder, {height:0, opacity:0}, {duration: 0.9, opacity:1.0, height: '12rem', ease: "expo.out"});			
				}});

                
            }

            function getChildWorldPosition(){
                let target = new THREE.Vector3(); // create once an reuse it
                const child = meshg.children[0];

                child.getWorldPosition( target );

                console.log(target);

                meshg.children[0].scale.x *= 10;
                meshg.children[0].scale.z *= 10;
                meshg.children[0].scale.y *= 10;

                meshg.children[0].position.y = -100;

                child.getWorldPosition( target );
                console.log(target);
                
            }

            window.getChildWorldPosition = getChildWorldPosition;

            window.getCamWorldDirection = function(){
               
                let target = new THREE.Vector3();
                console.log(camera.getWorldDirection(target));
            }

            window.calculateStarsPosition = function(scale){

                let scalarFactor;
                if(!scale){
                    scalarFactor = 1000.0;
                }else{
                    scalarFactor = scale;
                }

                planeMesh.scale.set(15, 15, 15);
                
                const directionVector = new THREE.Vector3();
                directionVector.x = starsPos[0].x - originPos.x;
                directionVector.y = starsPos[0].y - originPos.y;
                directionVector.z = starsPos[0].z - originPos.z;

                directionVector.normalize();
                
                let starPos = new THREE.Vector3();
                starPos.x = originPos.x + directionVector.x * scalarFactor;
                starPos.y = originPos.y + directionVector.y * scalarFactor;
                starPos.z = originPos.z + directionVector.z * scalarFactor;

                planeMesh.position.copy(starPos);
                console.log(planeMesh.position);
                planeMesh.quaternion.copy( camera.quaternion );
            }


            function computeScreenSpaceBoundingBox(mesh) {
                //var vertices = mesh.geometry.vertices;
                camera.updateMatrix();
                camera.updateMatrixWorld();
                camera.updateProjectionMatrix();
                camera.updateWorldMatrix();     
                
                
                //mesh.matrixAutoUpdate = true;

                mesh.geometry.computeBoundingBox();
                let bb = new THREE.Box3();
                bb.copy(mesh.geometry.boundingBox).applyMatrix4(mesh.matrixWorld);
                //bb.quaternion.copy(camera.quaternion);

                console.log(bb);

                var vertex = new THREE.Vector3();
                var max = new THREE.Vector2(1, 1);
                var min = new THREE.Vector2(1, 1);

               
                
                //vertex.copy(bb.min);
                let vertexScreenSpace1 = bb.min.clone().project(camera);
                min.copy(vertexScreenSpace1);
                

                //vertex.copy(bb.max);
                //camera.updateMatrixWorld();
                let vertexScreenSpace2 = bb.max.clone().project(camera);
                max.copy(vertexScreenSpace2);
            
                console.log(max);
                console.log(min);

                return new THREE.Box2(normalizedToPixels(min), normalizedToPixels(max));
            }

            function computeScreenSpaceBoundingBox2(mesh) {

                //camera.updateMatrix();
                //camera.updateMatrixWorld();
                camera.updateProjectionMatrix();

                let vertices = mesh.userData.vertices;

                

                var vertex = new THREE.Vector3();
                var min = new THREE.Vector2(1, 1);
                var max = new THREE.Vector2(-1, -1);

                mesh.updateMatrixWorld();

                for (var i = 0; i < vertices.length; i++) {
                    var vertexWorldCoord = vertex.copy(vertices[i]).applyMatrix4(mesh.matrixWorld);
                    var vertexScreenSpace = vertexWorldCoord.project(camera);
                    min.min(vertexScreenSpace);
                    max.max(vertexScreenSpace);
                }

                

                return new THREE.Box2(normalizedToPixels(min), normalizedToPixels(max));
            }

            function normalizedToPixels(coord){
                var halfScreen = new THREE.Vector2(window.innerWidth/2, window.innerHeight/2)
                return coord.clone().multiply(halfScreen).add(halfScreen);
            }


		</script>

	</body>
</html>

