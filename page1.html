<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Moshi Moshi</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link rel="preconnect" href="https://fonts.googleapis.com">
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
		<link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300&display=swap" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="./assets/main.css">
		<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.0/gsap.min.js"></script>
		<script src="./jsm/lottie_canvas.js"></script>

		<style>
			body {
				color: #000;
				overflow-x:hidden;
				overflow-y:hidden;
				font-family: 'Nunito', sans-serif;
				background-color: #fafeff;
				background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100%25' height='100%25' viewBox='0 0 1600 800'%3E%3Cg fill-opacity='0.54'%3E%3Cpath fill='%23d7f0fe' d='M486 705.8c-109.3-21.8-223.4-32.2-335.3-19.4C99.5 692.1 49 703 0 719.8V800h843.8c-115.9-33.2-230.8-68.1-347.6-92.2C492.8 707.1 489.4 706.5 486 705.8z'/%3E%3Cpath fill='%23b6d8fb' d='M1600 0H0v719.8c49-16.8 99.5-27.8 150.7-33.5c111.9-12.7 226-2.4 335.3 19.4c3.4 0.7 6.8 1.4 10.2 2c116.8 24 231.7 59 347.6 92.2H1600V0z'/%3E%3Cpath fill='%2396b7f5' d='M478.4 581c3.2 0.8 6.4 1.7 9.5 2.5c196.2 52.5 388.7 133.5 593.5 176.6c174.2 36.6 349.5 29.2 518.6-10.2V0H0v574.9c52.3-17.6 106.5-27.7 161.1-30.9C268.4 537.4 375.7 554.2 478.4 581z'/%3E%3Cpath fill='%23798fee' d='M0 0v429.4c55.6-18.4 113.5-27.3 171.4-27.7c102.8-0.8 203.2 22.7 299.3 54.5c3 1 5.9 2 8.9 3c183.6 62 365.7 146.1 562.4 192.1c186.7 43.7 376.3 34.4 557.9-12.6V0H0z'/%3E%3Cpath fill='%235e63e5' d='M181.8 259.4c98.2 6 191.9 35.2 281.3 72.1c2.8 1.1 5.5 2.3 8.3 3.4c171 71.6 342.7 158.5 531.3 207.7c198.8 51.8 403.4 40.8 597.3-14.8V0H0v283.2C59 263.6 120.6 255.7 181.8 259.4z'/%3E%3Cpath fill='%237e82ea' d='M1600 0H0v136.3c62.3-20.9 127.7-27.5 192.2-19.2c93.6 12.1 180.5 47.7 263.3 89.6c2.6 1.3 5.1 2.6 7.7 3.9c158.4 81.1 319.7 170.9 500.3 223.2c210.5 61 430.8 49 636.6-16.6V0z'/%3E%3Cpath fill='%239ea1ef' d='M454.9 86.3C600.7 177 751.6 269.3 924.1 325c208.6 67.4 431.3 60.8 637.9-5.3c12.8-4.1 25.4-8.4 38.1-12.9V0H288.1c56 21.3 108.7 50.6 159.7 82C450.2 83.4 452.5 84.9 454.9 86.3z'/%3E%3Cpath fill='%23bfc1f5' d='M1600 0H498c118.1 85.8 243.5 164.5 386.8 216.2c191.8 69.2 400 74.7 595 21.1c40.8-11.2 81.1-25.2 120.3-41.7V0z'/%3E%3Cpath fill='%23dfe0fa' d='M1397.5 154.8c47.2-10.6 93.6-25.3 138.6-43.8c21.7-8.9 43-18.8 63.9-29.5V0H643.4c62.9 41.7 129.7 78.2 202.1 107.4C1020.4 178.1 1214.2 196.1 1397.5 154.8z'/%3E%3Cpath fill='%23ffffff' d='M1315.3 72.4c75.3-12.6 148.9-37.1 216.8-72.4h-723C966.8 71 1144.7 101 1315.3 72.4z'/%3E%3C/g%3E%3C/svg%3E");
				background-attachment: fixed;
				background-repeat:repeat;
				background-size: cover;
				background-position: center center;
			}

			.frame {
			  position: absolute;
			  top: 35%;
			  left: 50%;
			  width: 400px;
			  height: 400px;
			  margin-top: -200px;
			  margin-left: -200px;
			  border-radius: 2px;
			  z-index:600;
			  color: #fff;
			  opacity:0;
			  transition: opacity 0.9s ease-in-out;
			}

            canvas {
    display: block;
}

#canvas_container {
    width: 100%;
    height: 100vh;
}

    #start-button{
        position: absolute;
        top: 40%;
        left: 50%;
        transform: translate(-50%);
    }

			
		</style>
		<script>
		 var camerag, sceneg, meshg, rendererg;

		</script>
	</head>

	<body>
		<!--<div id="splash"></div>-->

		<!--<video id="video" loop crossOrigin="anonymous" playsinline style="display:none">
			<source src="assets/dhvideo.mp4" type='video/mp4'>
		</video>-->

        <button id="start-button" onclick="handleEnterClick()">Enter</button>

        <div id="canvas_container"></div>


		<script type="module">

			import * as THREE from './build/three.module.js';

			import { OrbitControls } from './jsm/OrbitControls.js';
            import { PointerLockControls } from './jsm/PointerLockControls.js';
            import { SVGLoader } from './jsm/SVGLoader.js';
			import { LottieLoader } from './jsm/LottieLoader.js';
			import { TransformControls } from './jsm/TransformControls.js';
            import { GLTFLoader } from './jsm/GLTFLoader.js';

			import { EffectComposer } from './jsm/EffectComposer.js';
			import { RenderPass } from './jsm/RenderPass.js';
			import { UnrealBloomPass } from './jsm/UnrealBloomPass.js';

            import { GUI } from './jsm/lil-gui.module.min.js';

			let renderer,
            scene,
            camera,
            sphereBg,
            nucleus,
            stars,
            bloomPass,
            composer,
            controls,
            plControls,
            container = document.getElementById("canvas_container"),
            timeout_Debounce,
            //noise = new SimplexNoise(),
            cameraSpeed = 0,
            bloomAnimationCounter = 0,
            blobScale = 3;

            let raycaster = new THREE.Raycaster( new THREE.Vector3(), new THREE.Vector3());
			const pointer = new THREE.Vector2();
            const mouse3D = new THREE.Vector3();
            let model2, selectedObjectIndex = -1;

            let bgTextures = [];

            const params = {
				exposure: 0.1,
				bloomThreshold: 0.963,
                bloomStrength: 0.381,
				bloomRadius: 0.26,
			}; 


            init();
            animate();

            

            function init() {
                scene = new THREE.Scene();
                sceneg = scene;

                camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 10, 5000)
                camera.position.set(0, -25, 0);
                camera.lookAt(0.71, 0.17, 0.67);
                camerag = camera;

                const directionalLight = new THREE.DirectionalLight("#fff", 2);
                directionalLight.position.set(0, 50, -20);
                scene.add(directionalLight);

                let ambientLight = new THREE.AmbientLight("#ffffff", 1);
                ambientLight.position.set(0, 20, 20);
                scene.add(ambientLight);

                renderer = new THREE.WebGLRenderer({
                    antialias: true,
                    /*alpha: true*/
                });
                renderer.setSize(container.clientWidth, container.clientHeight);
                //renderer.toneMapping = THREE.ACESFilmicToneMapping;
                //renderer.toneMapping = THREE.ReinhardToneMapping;
                //renderer.outputEncoding = THREE.sRGBEncoding;
                //renderer.toneMappingExposure = 0.6;
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                //OrbitControl
                /*controls = new OrbitControls(camera, renderer.domElement);
                //controls.autoRotate = true;
                //controls.autoRotateSpeed = 4;
                //controls.maxDistance = 450;
                //controls.minDistance = 150;
                controls.enablePan = false;*/

                plControls = new PointerLockControls( camera, renderer.domElement);

                scene.add( plControls.getObject() );

                

                function handleEnterClick(){
                    plControls.lock();

                    document.getElementById('start-button').style.display = 'none';
                }

                window.handleEnterClick = handleEnterClick;

                

                const renderScene = new RenderPass( scene, camera );

				bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );


                const loader = new THREE.TextureLoader();
                const textureSphereBg = loader.load('./assets/hdri-1.png');
                /*const texturenucleus = loader.load('https://i.ibb.co/hcN2qXk/star-nc8wkw.jpg');
                const textureStar = loader.load("https://i.ibb.co/ZKsdYSz/p1-g3zb2a.png");
                const texture1 = loader.load("https://i.ibb.co/F8by6wW/p2-b3gnym.png");  
                const texture2 = loader.load("https://i.ibb.co/yYS2yx5/p3-ttfn70.png");
                const texture4 = loader.load("https://i.ibb.co/yWfKkHh/p4-avirap.png");*/

                const constellation1Tex = loader.load('./assets/constellations/1.png');
                const constellation2Tex = loader.load('./assets/constellations/2.png');
                const constellation3Tex = loader.load('./assets/constellations/3.png');
                const constellation4Tex = loader.load('./assets/constellations/4.png');

                const bg1Tex = loader.load('./assets/constellations/bg1.png');
                bgTextures.push(bg1Tex);
                const bg2Tex = loader.load('./assets/constellations/bg2.png');
                bgTextures.push(bg2Tex);
                const bg3Tex = loader.load('./assets/constellations/bg3.png');
                bgTextures.push(bg3Tex);
                const bg4Tex = loader.load('./assets/constellations/bg4.png');
                bgTextures.push(bg4Tex);

                const transparentTex = loader.load('./assets/constellations/transparent.png');


                /*  Nucleus  */   
                /*texturenucleus.anisotropy = 16;
                let icosahedronGeometry = new THREE.IcosahedronGeometry(30, 10);
                let lambertMaterial = new THREE.MeshPhongMaterial({ map: texturenucleus });
                nucleus = new THREE.Mesh(icosahedronGeometry, lambertMaterial);
                //scene.add(nucleus);


                /*    Sphere  Background   */
                textureSphereBg.anisotropy = 32;
                let geometrySphereBg = new THREE.SphereBufferGeometry(4000, 40, 40);
                let materialSphereBg = new THREE.MeshBasicMaterial({
                    side: THREE.BackSide,
                    map: textureSphereBg,
                });
                sphereBg = new THREE.Mesh(geometrySphereBg, materialSphereBg);
                scene.add(sphereBg);


                /*    Moving Stars   */
                /*let starsGeometry = new THREE.Geometry();

                for (let i = 0; i < 50; i++) {
                    let particleStar = randomPointSphere(150); 

                    particleStar.velocity = THREE.MathUtils.randInt(50, 200);

                    particleStar.startX = particleStar.x;
                    particleStar.startY = particleStar.y;
                    particleStar.startZ = particleStar.z;

                    starsGeometry.vertices.push(particleStar);
                }
                let starsMaterial = new THREE.PointsMaterial({
                    size: 5,
                    color: "#ffffff",
                    transparent: true,
                    opacity: 0.8,
                    map: textureStar,
                    blending: THREE.AdditiveBlending,
                });
                starsMaterial.depthWrite = false;  
                stars = new THREE.Points(starsGeometry, starsMaterial);
                scene.add(stars); */

                let index = 0;
                const modelLoader = new GLTFLoader();

                modelLoader.load(
                        './assets/planes.glb',
                        function ( gltf ) {

                            const model = gltf.scene;
                            model.name = 'objectGroup';
                            meshg = model;
                            model.traverse((child) => {
                                
                                if(child.isMesh){
                                    /*child.scale.x *= 0.05;
                                    child.scale.y *= 0.05;
                                    child.scale.z  *= 0.05;*/
                                    //child.position.x *= 100;
                                    //child.position.z *= 100;

                                    child.material = new THREE.MeshBasicMaterial({transparent: true });

                                    if(child.name === 'plane1'){
                                        child.material.map = constellation1Tex;
                                    }

                                    if(child.name === 'plane2'){
                                        child.material.map = constellation2Tex;
                                    }

                                    if(child.name === 'plane3'){
                                        child.material.map = constellation3Tex;
                                    }

                                    if(child.name === 'plane4'){
                                        child.material.map = constellation4Tex;
                                    }

                                    if(child.name === 'plane5'){
                                        child.scale.set(0,0,0);
                                    }

                                    child.userData.index = index;
                                    child.userData.name = child.name;
                                    index++;

                                    child.material.needsUpdate = true;
                                }
                            });

                            model.scale.set(10,10,10);
                            //gltf.scene.position.x *= 50;
                            //gltf.scene.position.z *= 50;
                            model.position.y = -150;

                            model2 = model.clone();
                            model2.renderOrder = -1;

                            model2.traverse((child) => {
                                if(child.isMesh){
                                    child.material = new THREE.MeshBasicMaterial({ map: transparentTex, transparent: true, opacity: 0});
                                }
                            })

                            scene.add( model );
                            scene.add(model2);

                        },
                        // called while loading is progressing
                        function ( xhr ) {

                            console.log( ( xhr.loaded / xhr.total * 100 ) + '% loaded' );

                        },
                        // called when loading has errors
                        function ( error ) {

                            console.log( 'An error happened' );

                        }
                    );


                /*    Fixed Stars   */
                function createStars(texture, size, total) {
                    let pointGeometry = new THREE.Geometry();
                    let pointMaterial = new THREE.PointsMaterial({
                        size: size,
                        map: texture,
                        blending: THREE.AdditiveBlending,                      
                    });

                    for (let i = 0; i < total; i++) {
                        let radius = THREE.MathUtils.randInt(149, 70); 
                        let particles = randomPointSphere(radius);
                        pointGeometry.vertices.push(particles);
                    }
                    return new THREE.Points(pointGeometry, pointMaterial);
                }
               /* scene.add(createStars(texture1, 15, 20));   
                scene.add(createStars(texture2, 5, 5));
                scene.add(createStars(texture4, 7, 5));*/


                function randomPointSphere (radius) {
                    let theta = 2 * Math.PI * Math.random();
                    let phi = Math.acos(2 * Math.random() - 1);
                    let dx = 0 + (radius * Math.sin(phi) * Math.cos(theta));
                    let dy = 0 + (radius * Math.sin(phi) * Math.sin(theta));
                    let dz = 0 + (radius * Math.cos(phi));
                    return new THREE.Vector3(dx, dy, dz);
                }


                const gui = new GUI();

				gui.add( params, 'exposure', 0.1, 2 ).onChange( function ( value ) {

					renderer.toneMappingExposure = Math.pow( value, 4.0 );

				} );

				gui.add( params, 'bloomThreshold', 0.0, 1.0 ).onChange( function ( value ) {

					bloomPass.threshold = Number( value );

				} );

				gui.add( params, 'bloomStrength', 0.0, 3.0 ).onChange( function ( value ) {

					bloomPass.strength = Number( value );

				} );

				gui.add( params, 'bloomRadius', 0.0, 1.0 ).step( 0.01 ).onChange( function ( value ) {

					bloomPass.radius = Number( value );

				} );
            }


            function animate() {

                //Stars  Animation
                /*stars.geometry.vertices.forEach(function (v) {
                    v.x += (0 - v.x) / v.velocity;
                    v.y += (0 - v.y) / v.velocity;
                    v.z += (0 - v.z) / v.velocity;

                    v.velocity -= 0.3;

                    if (v.x <= 5 && v.x >= -5 && v.z <= 5 && v.z >= -5) {
                        v.x = v.startX;
                        v.y = v.startY;
                        v.z = v.startZ;
                        v.velocity = THREE.MathUtils.randInt(50, 300);
                    }
                });*/


                //Nucleus Animation
                /*nucleus.geometry.vertices.forEach(function (v) {
                    let time = Date.now();
                    v.normalize();
                    let distance = nucleus.geometry.parameters.radius + noise.noise3D(
                        v.x + time * 0.0005,
                        v.y + time * 0.0003,
                        v.z + time * 0.0008
                    ) * blobScale;
                    v.multiplyScalar(distance);
                })
                nucleus.geometry.verticesNeedUpdate = true;
                nucleus.geometry.normalsNeedUpdate = true;
                nucleus.geometry.computeVertexNormals();
                nucleus.geometry.computeFaceNormals();*/
               /* nucleus.rotation.y += 0.002; */

               //raycasting

               if(plControls.isLocked && bloomAnimationCounter % 50 == 0){
                raycaster.ray.origin.copy(plControls.getObject().position);
                plControls.getDirection( mouse3D )
                raycaster.ray.direction.copy(mouse3D);

                const intersects = raycaster.intersectObjects(scene.children, true);

                if(intersects.length > 0){
                    if(intersects[0].object.name && intersects[0].object.userData.index !== selectedObjectIndex)
                    handleRaycast2(intersects[0].object.userData);
                }
               }
               


                //Sphere Beckground Animation
                //sphereBg.rotation.x += 0.002;
                sphereBg.rotation.y += 0.003;
                //sphereBg.rotation.x += 0.0001;
                if(meshg){
                    meshg.rotation.y += 0.0025;
                    model2.rotation.y += 0.0025;
                } 
                //sphereBg.rotation.z += 0.002;

                if(bloomAnimationCounter % 10 == 0){

                }

                bloomAnimationCounter++;

                //controls.update();
                //stars.geometry.verticesNeedUpdate = true;
                renderer.render(scene, camera);
                //composer.render();


                requestAnimationFrame(animate);
            }



            /*     Resize     */
            window.addEventListener("resize", () => {
                clearTimeout(timeout_Debounce);
                timeout_Debounce = setTimeout(onWindowResize, 80);
            });

            function onWindowResize() {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            }

            

            function handleRaycast(event){
                
                pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
				pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

				raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( scene.children );

                if(intersects.length > 0){
                    console.log(intersects[0].object.name);
                }
                


            }

            window.addEventListener("pointerdown", handleRaycast);


            function handleRaycast2(objData){
                
                selectedObjectIndex = objData.index;
                const selectedObjMat = meshg.children[selectedObjectIndex].material;

                //selectedObjMat.color.set(0x000000);
                //selectedObjMat.needsUpdate = true;

                const selectedBGMat = model2.children[selectedObjectIndex].material;
                selectedBGMat.map = bgTextures[selectedObjectIndex];
                selectedBGMat.needsUpdate = true;

                gsap.to(selectedBGMat, { opacity: 0.85, duration:1, ease:"expo.out", onUpdate: () => {
                    selectedBGMat.needsUpdate = true;
                },onComplete: () => {
						
						
						//createInnerPage1();

						//showAnnotations = true;	
						//controls.target.set(annotations[id].position.x, annotations[id].position.y, annotations[id].position.z );
						//gsap.fromTo(annotDescHolder, {height:0, opacity:0}, {duration: 0.9, opacity:1.0, height: '12rem', ease: "expo.out"});			
				}});

                
            }

            function getChildWorldPosition(){
                let target = new THREE.Vector3(); // create once an reuse it
                const child = meshg.children[0];

                child.getWorldPosition( target );

                console.log(target);

                meshg.children[0].scale.x *= 10;
                meshg.children[0].scale.z *= 10;
                meshg.children[0].scale.y *= 10;

                meshg.children[0].position.y = -100;

                child.getWorldPosition( target );
                console.log(target);
                
            }

            window.getChildWorldPosition = getChildWorldPosition;




		</script>

	</body>
</html>

